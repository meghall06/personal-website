<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Meghan Hall">
<meta name="dcterms.date" content="2021-02-23">

<title>Meghan Hall</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../icon-32.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>

      .quarto-title-block .quarto-title-banner {
        background: #1F2041;
      }
</style>


<link rel="stylesheet" href="../blog.css">
</head>

<body class="floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">meghan<br>hall</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../blog/index.html"> 
<span class="menu-text">BLOG</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../talks/index.html"> 
<span class="menu-text">TALKS</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default toc-left page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">The FOGO Trend and the Importance of Faceoffs on the Penalty Kill</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">hockey analysis</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Meghan Hall </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">2021-02-23</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">CONTENTS</h2>
   
  <ul>
  <li><a href="#are-fogos-real" id="toc-are-fogos-real" class="nav-link active" data-scroll-target="#are-fogos-real">Are FOGOs real?</a></li>
  <li><a href="#why-this-focus-on-pk-faceoffs" id="toc-why-this-focus-on-pk-faceoffs" class="nav-link" data-scroll-target="#why-this-focus-on-pk-faceoffs">Why this focus on PK faceoffs?</a></li>
  <li><a href="#should-fogos-be-real" id="toc-should-fogos-be-real" class="nav-link" data-scroll-target="#should-fogos-be-real">Should FOGOs be real?</a></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>The Baader–Meinhof phenomenon is a fancy term for a simple idea: when you learn about a concept, or hear a new word, then all of a sudden you start seeing it everywhere. It’s usually a form of cognitive bias because your increased attention to this new thing tends to make it seem like it’s occurring at a higher frequency than it actually is.</p>
<p>This happened to me earlier this year with FOGO. If you’re unaware, like I was, FOGO stands for “face off, get off.” It’s a popular term in lacrosse, but in hockey it generally refers to a player on the penalty kill whose main job is the faceoff—they take the faceoff and then leave the ice as soon as possible to be replaced by another player. All of a sudden, I started seeing FOGO references everywhere (i.e., on Twitter and in a few articles), so I assumed it might be a new trend.</p>
<section id="are-fogos-real" class="level3">
<h3 class="anchored" data-anchor-id="are-fogos-real">Are FOGOs real?</h3>
<p>How could we go about determining whether this FOGO thing is actually in fact a trend? Since the aim of a FOGO is to take the faceoff and then leave the ice, we could see whether the average shift length of the player taking the faceoff is changing over the past few seasons. The graph below shows, for each team per season, the average shift length of the players who took the initial defensive zone faceoff of a 4v5 penalty kill. That is, how long did they stay on the ice after that faceoff during that penalty kill?</p>
<p><img src="shift_FOteam.png" class="img-fluid"></p>
<p>If the FOGO was becoming a trend, we might see this average shift length moving downward, but that doesn’t appear to be the case. (The wider variation seen in the 2020-21 season isn’t too surprising, as it’s still fairly early in the season and the averages haven’t necessarily stabilized yet.)</p>
<p>We could also look at this same average shift length, this time grouped by the result of that faceoff. Since after all, the ideal outcome of a FOGO is for the player to <em>win</em> the faceoff and then leave the ice. But, from the graph below, there doesn’t appear to be an emerging trend there, either.</p>
<p><img src="shift_FOresult.png" class="img-fluid"></p>
<p>Lastly, what if we looked at individual players? That is, who actually takes these faceoffs? (Again, restricting to the initial defensive zone faceoff of a 4v5 penalty kill.) In the graph below, each dot represents a player from one of the last several seasons. The x-axis shows the percent time they spent on their team’s PK (adjusted for games played, so a player missing a chunk of games for an injury, for example, wouldn’t be penalized), and the y-axis shows the percent of these initial defensive zone PK faceoffs they took.</p>
<p><img src="FOGO.png" class="img-fluid"></p>
<p>We would expect to see any FOGOs up in that upper-left corner: players who take a lot of faceoffs on the penalty kill but don’t actually play on the PK very much. But as you can see, there’s only one solitary dot in that region: Jason Spezza of the Toronto Maple Leafs this season, who has taken 67% of these initial defensive zone faceoffs but doesn’t spend that much time on the penalty kill otherwise. No player over the past several seasons is particularly close to that specific combination—the closest is that blue dot a bit below, Claude Giroux of the Philadelphia Flyers who took 48% of those faceoffs in the 2019-20 season but didn’t get much other PK time.</p>
</section>
<section id="why-this-focus-on-pk-faceoffs" class="level3">
<h3 class="anchored" data-anchor-id="why-this-focus-on-pk-faceoffs">Why this focus on PK faceoffs?</h3>
<p><a href="http://statsportsconsulting.com/main/wp-content/uploads/FaceoffAnalysis12-12.pdf" target="_blank">Much</a> <a href="https://arxiv.org/pdf/1902.02397.pdf" target="_blank">has</a> <a href="https://www.arcticicehockey.com/2011/10/18/2491154/impact-of-winning-an-offensive-zone-faceoff-even-strength-vs-power" target="_blank">been</a> <a href="https://hockey-graphs.com/2015/01/15/the-relationship-between-corsi-and-winning-faceoffs/" target="_blank">written</a> <a href="https://archive.is/DEvjy" target="_blank">about</a> faceoffs and their importance—or lack thereof. So what about the specific situation of the defensive zone faceoff that kicks off a 4v5 penalty kill?</p>
<p>A faceoff “win” can be subjective, so before we look at the potential impacts of a faceoff win, what actually happens after the initial defenzive zone faceoff on a 4v5 penalty kill? In an attempt to answer this question, I watched 113 of these faceoffs from the 2019-20 regular season to examine the relationship between a faceoff win, as per the recorded event in the NHL play-by-play data, and the primary goal of the penalty killing team: clearing the puck out of the offensive zone.</p>
<p><img src="tracked.png" class="img-fluid"></p>
<p>As shown in the graph above, the relationship was pretty stark in this sample. When the PK team lost that initial faceoff, they were only able to clear the puck on the resulting possession five percent of the time. But when they won that faceoff, their clear rate increased to nearly 63 percent.</p>
<p>That relationship is reflected in the graph below, which shows the distribution of shot attempts by the power play team per second, grouped by the result of that initial defensive zone faceoff. Penalty kill teams who lose that initial faceoff—meaning they’re likely stuck in their defensive zone and likely facing the power play’s top unit— see a spike in power play shot attempts for the first portion of the penalty.</p>
<p><img src="PP_shots.png" class="img-fluid"></p>
<p>This initial discrepancy sums up to quite a difference in shot attempt rates over the life of the penalty. Shown below are the power play shot attempt rates for the past several seasons, per the result of the initial faceoff from the perspective of the penalty killing team. (To keep in line with the rest of the analysis, this includes 5v4 penalties only that start with a defensive zone faceoff, from the perspective of the penalty killing team.) It’s a significant difference, with a lower shot attempt generation rate associated with a penalty kill faceoff win, and a similar relationship can be seen with the goals rate.</p>
<p><img src="impacts.png" class="img-fluid"></p>
</section>
<section id="should-fogos-be-real" class="level3">
<h3 class="anchored" data-anchor-id="should-fogos-be-real">Should FOGOs be real?</h3>
<p>So, given the importance of the initial defensive zone faceoff on a 4v5 penalty kill, maybe FOGOs <em>should</em> be a thing! There’s of course the risk of your FOGO losing the faceoff and then being stuck on the ice in the defensive zone for a while, which might not be an ideal circumstance (especially if there’s a reason that player doesn’t play on the penalty kill in the first place.) But the impacts of an initial faceoff win might be enough to give it a shot.</p>
<p>Who would be good potential FOGO candidates?</p>
<table class="table">
<thead>
<tr class="header">
<th>Season</th>
<th>Player</th>
<th>Team</th>
<th>Faceoff Win</th>
<th>PK Time</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>20192020</td>
<td>BO.HORVAT</td>
<td>VAN</td>
<td>56.1%</td>
<td>8.1%</td>
</tr>
<tr class="even">
<td>20192020</td>
<td>CLAUDE.GIROUX</td>
<td>PHI</td>
<td>58.9%</td>
<td>18.3%</td>
</tr>
<tr class="odd">
<td>20192020</td>
<td>GABRIEL.LANDESKOG</td>
<td>COL</td>
<td>55.4%</td>
<td>1.4%</td>
</tr>
<tr class="even">
<td>20192020</td>
<td>J.T..MILLER</td>
<td>VAN</td>
<td>58.0%</td>
<td>12.1%</td>
</tr>
<tr class="odd">
<td>20192020</td>
<td>MATT.DUCHENE</td>
<td>NSH</td>
<td>55.8%</td>
<td>0.8%</td>
</tr>
<tr class="even">
<td>20192020</td>
<td>SIDNEY.CROSBY</td>
<td>PIT</td>
<td>55.0%</td>
<td>6.5%</td>
</tr>
<tr class="odd">
<td>20192020</td>
<td>TYLER.SEGUIN</td>
<td>DAL</td>
<td>58.9%</td>
<td>13.8%</td>
</tr>
<tr class="even">
<td>20202021</td>
<td>CLAUDE.GIROUX</td>
<td>PHI</td>
<td>55.9%</td>
<td>16.8%</td>
</tr>
<tr class="odd">
<td>20202021</td>
<td>DAVID.KREJCI</td>
<td>BOS</td>
<td>58.9%</td>
<td>0.0%</td>
</tr>
<tr class="even">
<td>20202021</td>
<td>JOHN.TAVARES</td>
<td>TOR</td>
<td>57.8%</td>
<td>0.7%</td>
</tr>
<tr class="odd">
<td>20202021</td>
<td>LEON.DRAISAITL</td>
<td>EDM</td>
<td>56.5%</td>
<td>14.5%</td>
</tr>
<tr class="even">
<td>20202021</td>
<td>SIDNEY.CROSBY</td>
<td>PIT</td>
<td>57.9%</td>
<td>3.3%</td>
</tr>
<tr class="odd">
<td>20202021</td>
<td>VINCENT.TROCHECK</td>
<td>CAR</td>
<td>55.7%</td>
<td>18.8%</td>
</tr>
</tbody>
</table>
<p>Shown above are players from this season and the previous one who have a 5v5 faceoff win percentage over 55% and play under 20% of their team’s PK minutes. I’ll keep my eye out for anyone joining Jason Spezza in the vaunted FOGO category.</p>
<p><em>Play-by-play data sourced via the <a href="https://evolving-hockey.com/" target="_blank">Evolving-Hockey</a> scraper!</em></p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
          // target, if specified
          link.setAttribute("target", "_blank");
          if (link.getAttribute("rel") === null) {
            link.setAttribute("rel", "noopener");
          }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>